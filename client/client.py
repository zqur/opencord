import socket 
import sys
from datetime import datetime 
import json 
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from Crypto.Cipher import AES, PKCS1_OAEP
"""
        The profile hash is either generated by a third party, an Opencord server, or the Verified Opencord Web server. 

        There might be a profile hash table so a profile can be used with multiple different servers. 
        
                

"""




# This class is used for communication and has all communication information 
class Communication:
    def __init__(self):
        self.session_id = None # ID of the chat session 
        self.client_version = "" # Version of the client
        self.server_version = "" # Version of the server
        self.profile_hash = (sys.argv[1])  # Hash of the user profile  (needs to be implemented)
        self.authorization = "" # Pending auth to begin using the service 
        self.sessionToken = "" # Token for the session 
        self.messageNumber = 0 # keeps track of the number of messages sent so far
        self.private_key = None # Private key (used to decrypt the servers response)
        self.public_key = None # Public key (used to encrypt the server response)
        self.symmetric_key = None # symmetric key (sent by the server and used for the rest of the session)

    
    
    def send(self, content):
        message = {
            "n": self.messageNumber, 
            "time": (datetime.now()).strftime("%Y-%m-%d %H:%M:%S"),
            "content":content,  
            "token": "NEED TO IMPLEMENT!", 
        }

        self.messageNumber += 1
        return message
        
    def generateKeys(self):        
        key = RSA.generate(2048)
        self.private_key = key.export_key()
        self.public_key = key.export_key().public_key()
    
    
    def decrypt(self, message):
        cipher_rsa = PKCS1_OAEP.new(self.private_key)
        session_key = cipher_rsa.decrypt(enc_session_key)
        
        
        


        
        
    # Begin communication with the server 
    def begin(self):
        start_object = {}
        start_object["service"] = 0 # 0 is to init the service for this connection and sends back the server verification hash
        start_object["client_version"] = self.client_version # Sends the server the version of the client 
        start_object["profile"] = self.profile_hash # The profile ID of the user profile
        return start_object



        


class Data:
    def __init__(self):
        self.server_id = "" # Server ID
        self.server_name = "" # Server name
        self.key = "" # Key 
        self.type = "" # Type of communication (client to client, client to server, )
        self.client_version = "" # Version of the client
        self.client_hash = "" # Hash of the client 
        

    def getData(self):
        pass

    def getChat(self, start_date, end_date):
        pass
    
    # Initiate the communication with the server 
    def start(self):
        pass



if __name__ == "__main__":
    HOST, PORT = "10.0.0.130", 9090
    # data = " ".join(sys.argv[1:])
    chat = Communication()
    # Create a socket (SOCK_STREAM means a TCP socket)
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock: 
        # Connect to server and send data
        data = None
        sock.connect((HOST, PORT))
        hi_packet = json.dumps(chat.begin()).encode('utf-8') # send in the starter packet
        sock.sendall(hi_packet) # Say hi to the server and authorize connection
        while data != "exit":
            data = input("Input:  ")
            d = chat.send(data)
            
            encoded_data = (json.dumps(d)).encode('utf-8')
            # sock.sendall(bytes(d + '\n', 'utf-8'))
            sock.sendall(encoded_data)

            received = str(sock.recv(1024), 'utf-8')
            print(received)


            # Receive data from the server and shut down 
    
    print(f"Sent: {data}")
    print(f"Received: {received}")