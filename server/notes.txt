
4 basic server classes:
- TCP Server: Uses TCP protocol, which provides for continuous 
    streams of data between the client and server. 
    If bind_and_activate is true, the constructor automatically attempts
    ot invoke the server_bind() and server_activate(). 
    
- UDP Server: Uses UDP protocol, or datagrams, which are discrete packets of information that
    may arrive out of order or be lost while in transit. Same parameters as TCP server. 
    
- UnixStreamServer
- UnixDatagramServer: Both of these are similar to TCP and UDP classes but use Unix domain 
    sockets. They are not available on non-Unix platforms. Same parameters as TCP server. 

    
Each of these classes process requests synchronously, each request must be completed before
the next request can be started. 

If each request takes a long time to complete because it requires a lot of computation, 
or because it returns a lot of data which the client is slow to process. The solution 
is to create a seperate process or thread to handle each request. 

ForkingMixIn and ThreadingMixIn mix-in classes can be used to support asynchronous behaviour. 

1. To create a server first you must create a request handler class by subclassing the 
BaseRequestHandler class and overriding its handle() method. 

    The handle() method will process incoming requests. 

2. You must instantiate one of the server classes, passing it the server's address and 
    the request handler class (it is recommended to use the server in a with statement).
    Then call the handle_request() or server_forever() method. 
    Finally, call server_close() to close the socket (unless you used a with statement)


When inheriting from ThreadingMixIn for threaded connection behavior, you should explicitly
declare how you want your threads to behave on an abrupt shutdown. 

The ThreadingMixIn class defines an attribute daemon_threads, which indicates whether or not 
the server should wait for thread termination. 

You should set the flag explicitly if you would like threads to behave autonomously; 
The default is False, meaning that Python will not exit until all threads created by 
ThreadingMixIn have exited. 

socketserver.ForkingMixIn.server_close() waits until all child processes complete, 
except if socketserver.ForkingMixIn.block_on_close attribute is false. 

socketserver.ThreadingMixIn.server_close() waits until all non-daemon threads complete, 
except if socketserver.ThreadingMixIn.block_on_close attribute is false. 
Use daemonic threads by setting ThreadingMixIn.daemon_threads to True to not wait 
until threads complete. 


socketserver.ForkingMixIn.server_close() and socketserver.ThreadingMixIn.server_close()
now waits until all child processes and non-daemonic threads complete. 

class socketserver.ForkingTCPServer
class socketserver.ForkingUDPServer
class socketserver.ThreadingTCPServer
class socketserver.ThreadingUDPServer

All these classes are pre-defined using the mix-in classes.

To implement a service, you must derive a class from BaseRequestHandler and redefine its
handle() method.

Don't use a forking server if the service contains state in memory that can be modified by 
different requests, since the modifications in the child process would never reach the initial
state kept in the parent process and passed to each child. In this case you can use a threading
server, but you would probably have to use locks to protect the integrity of the shared data.






